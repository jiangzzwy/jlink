package com.jlink.nebula.jdbc;

import com.jlink.nebula.jdbc.utils.ExceptionBuilder;
import com.vesoft.nebula.client.graph.net.NebulaPool;
import com.vesoft.nebula.client.graph.net.Session;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.*;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;

public class NebulaConnection implements Connection {
    private static final Logger logger = LoggerFactory.getLogger(NebulaConnection.class);
    
    private static final String FASTEST_STATEMENT = "RETURN 1";
    private final Session session;
    private final NebulaConfig config;
    private boolean autoCommit = true;
    private boolean closed = false;
    private boolean readOnly = false;
    private NebulaDatabaseMetaData metadata;
    private String schema;
    private Properties clientInfo;

    public static NebulaConnection newInstance(NebulaPool pool, NebulaConfig config) throws Exception {
        return new NebulaConnection(pool, config);
    }
    
    private NebulaConnection(NebulaPool pool, NebulaConfig config) throws Exception {
        this.config = config;
        this.session = pool.getSession(config.getUsername(), config.getPassword(), config.isReconnect());
        if (StringUtils.isNotBlank(config.getSpace())) {
            if (logger.isDebugEnabled()) {
                logger.debug("Use space " + config.getSpace());
            }
            session.execute("USE " + config.getSpace());
        }
    }

    public Session getSession() {
        return session;
    }

    public NebulaConfig getConfig() {
        return config;
    }

    @Override
    public Statement createStatement() throws SQLException {
        return NebulaStatement.newInstance(this);
    }

    @Override
    public Statement createStatement(int resultSetType,
                                     int resultSetConcurrency,
                                     int resultSetHoldability) throws SQLException {
        return NebulaStatement.newInstance(this);
    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        return NebulaStatement.newInstance(this);
    }

    @Override
    public PreparedStatement prepareStatement(String sql) throws SQLException {
        return new NebulaPreparedStatement(this, nativeSQL(sql));
    }

    @Override
    public PreparedStatement prepareStatement(String sql,
                                              int resultSetType,
                                              int resultSetConcurrency) throws SQLException {
        return new NebulaPreparedStatement(this, nativeSQL(sql));
    }

    @Override
    public PreparedStatement prepareStatement(String sql,
                                              int resultSetType,
                                              int resultSetConcurrency,
                                              int resultSetHoldability) throws SQLException {
        return new NebulaPreparedStatement(this, nativeSQL(sql));
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        return new NebulaPreparedStatement(this, nativeSQL(sql));
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        return new NebulaPreparedStatement(this, nativeSQL(sql));
    }

    @Override
    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        return new NebulaPreparedStatement(this, nativeSQL(sql));
    }
    
    /*-------------------事务-------------------------*/
    /* Nebula目前不支持事务，事务相关不做任何操作         */

    @Override
    public void setAutoCommit(boolean autoCommit) throws SQLException {
        this.autoCommit = autoCommit;
    }

    @Override
    public boolean getAutoCommit() throws SQLException {
        return this.autoCommit;
    }

    @Override
    public void commit() throws SQLException {
    }

    @Override
    public void rollback() throws SQLException {
    }

    @Override
    public void close() throws SQLException {
        this.session.release();
        this.closed = true;
    }

    @Override
    public boolean isClosed() throws SQLException {
        return this.closed;
    }
    
    /*-------------------事务-------------------------*/


    @Override
    public void setSchema(String schema) throws SQLException {
        try {
            this.session.execute("USE " + schema + ";");
            this.schema = schema;
        } catch (Exception e) {
            throw new SQLException(e);
        }
    }

    @Override
    public String getSchema() throws SQLException {
        return this.schema;
    }

    @Override
    public String nativeSQL(String sql) throws SQLException {
        return sql;
    }
    
    @Override
    public DatabaseMetaData getMetaData() throws SQLException {
        if(metadata == null){
            metadata = new NebulaDatabaseMetaData(this);
        }
        return metadata;
    }

    @Override
    public void setReadOnly(boolean readOnly) throws SQLException {
        this.readOnly = readOnly;
    }

    @Override
    public boolean isReadOnly() throws SQLException {
        return this.readOnly;
    }
    
    @Override
    public int getNetworkTimeout() throws SQLException {
        return this.config.getTimeout();
    }

    @Override
    public <T> T unwrap(Class<T> iface) throws SQLException {
        return Wrapper.unwrap(iface, this);
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        return Wrapper.isWrapperFor(iface, this.getClass());
    }

    @Override
    public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
        return new ListArray(typeName, elements);
    }

    @Override public void setClientInfo(String name, String value) throws SQLClientInfoException {
        if (name != null && value != null) {
            if (this.clientInfo == null) {
                this.clientInfo = new Properties();
            }
            this.clientInfo.setProperty(name, value);
        }
    }

    @Override public void setClientInfo(Properties properties) throws SQLClientInfoException {
        this.clientInfo = properties;
    }

    @Override public String getClientInfo(String name) throws SQLException {
        return (this.clientInfo != null) ? this.clientInfo.getProperty(name) : null;
    }

    @Override public Properties getClientInfo() throws SQLException {
        return this.clientInfo;
    }

    @Override
    public boolean isValid(int timeout) throws SQLException {
        if (timeout < 0) {
            throw new SQLException("Timeout can't be less than zero");
        }
        if (this.isClosed()) {
            return false;
        }

        try {
            this.session.execute(FASTEST_STATEMENT);
        } catch (Exception e) {
            return false;
        }

        return true;
    }

    /*---------------------------------*/
    /*       Not implemented yet       */
    /*---------------------------------*/

    @Override
    public CallableStatement prepareCall(String sql) throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }

    @Override
    public void setCatalog(String catalog) throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }

    @Override
    public String getCatalog() throws SQLException {
        return null;
    }

    @Override
    public void setTransactionIsolation(int level) throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }

    @Override
    public int getTransactionIsolation() throws SQLException {
        return TRANSACTION_NONE;
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        return null;
    }

    @Override
    public void clearWarnings() throws SQLException {

    }
    
    @Override
    public Map<String, Class<?>> getTypeMap() throws SQLException {
        return null;
    }

    @Override
    public void setTypeMap(Map<String, Class<?>> map) throws SQLException {

    }

    @Override
    public void setHoldability(int holdability) throws SQLException {

    }

    @Override
    public int getHoldability() throws SQLException {
        return 0;
    }

    @Override
    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }

    @Override
    public Savepoint setSavepoint() throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }

    @Override
    public Savepoint setSavepoint(String name) throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }

    @Override
    public void rollback(Savepoint savepoint) throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }

    @Override
    public void releaseSavepoint(Savepoint savepoint) throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }

    @Override
    public CallableStatement prepareCall(String sql,
                                         int resultSetType,
                                         int resultSetConcurrency,
                                         int resultSetHoldability) throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }



    @Override
    public Clob createClob() throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }

    @Override
    public Blob createBlob() throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }

    @Override
    public NClob createNClob() throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }

    @Override
    public SQLXML createSQLXML() throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }

    @Override
    public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }

    @Override
    public void abort(Executor executor) throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }

    @Override
    public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
        throw ExceptionBuilder.buildUnsupportedOperationException();
    }
}
